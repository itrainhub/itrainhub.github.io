---
layout: post
title: JavaScript 排序算法
date: 2016-12-1
category: JavaScript
tags: [JavaScript, 算法, 冒泡, 选择, 插入, 排序]
---

## 关于排序 ##

维基百科关于排序算法的描述如下：

>在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：
>
>输出结果为递增序列（递增是针对所需的排序顺序而言）
>
>输出结果是原输入的一种排列、或是重组
>
>虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。

排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，需要经过大量的推理和分析。

## 1. 冒泡排序 ##

### 1.1 简介 ###

冒泡排序（Bubble Sort）是一种简单的排序算法，它重复地遍历要排序的数列，每次比较相邻的两个元素，如果他们的顺序不满足排序条件就把他们交换过来。遍历数列的工作是重复地进行直到不再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小（或越大）的元素会经由交换慢慢“浮”到数列的顶端。

由于冒泡算法的简洁性，基本上大家都把它看作程序设计的入门算法。

### 1.2 算法描述 ###

我们先看一张图：

![冒泡排序](/images/posts/jssort/1.gif)

上图表明了冒泡排序的算法过程，按照从小到大（升序）排序。

分解一下，过程如下：

	未排序数列：6 5 3 1 8 7 2 4

	第一轮排序后：5 3 1 6 7 2 4 [8]

	第二轮排序后：3 1 5 6 2 4 [7] 8

	第三轮排序后：1 3 5 2 4 [6] 7 8

	第四轮排序后：1 3 2 4 [5] 6 7 8

	第五轮排序后：1 2 3 [4] 5 6 7 8

	第六轮排序后：1 2 [3] 4 5 6 7 8

	第七轮排序后：1 [2] 3 4 5 6 7 8

	最后排序结果为：1 2 3 4 5 6 7 8

每一轮排序都会将该轮中的最大值冒上来（用[]标记出来的），对上一轮已经排好序的数就不用再进行判断排序。

我们可以总结一下，冒泡排序的算法原理如下（按从小到大排序）：

*	比较相邻的元素。如果前一个比后一个大，就交换他们的顺序。
*	对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步完成后，最后的元素应该会是最大的数。
*	针对所有的元素重复以上的步骤，除了最后一个。
*	持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 1.3 算法实现 ###

代码：

	var array = [6, 5, 3, 1, 8, 7, 2, 4], // 未排序数组
		count = 0, // 记录排序总循环次数
		tmp; // 临时变量，用于交换元素位置

	console.log("排序前：", array);

	for (var i = 0, len = array.length - 1; i < len; i++) { // 控制比较轮数
		for (var j = 0, l = len - i; j < l; j++) { // 控制每轮比较次数
			count++; // 记录循环次数
			if (array[j] > array[j + 1]) {
				tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
			}
		}
		console.log("第" + (i + 1) + "轮排序：", array);
	}

	console.log("排序后：", array);
	console.log("共执行循环次数：", count);

执行结果：

	排序前： [6, 5, 3, 1, 8, 7, 2, 4]
	第1轮排序： [5, 3, 1, 6, 7, 2, 4, 8]
	第2轮排序： [3, 1, 5, 6, 2, 4, 7, 8]
	第3轮排序： [1, 3, 5, 2, 4, 6, 7, 8]
	第4轮排序： [1, 3, 2, 4, 5, 6, 7, 8]
	第5轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	第6轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	第7轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	排序后： [1, 2, 3, 4, 5, 6, 7, 8]
	共执行循环次数： 28

我们从上述结果中看到，第5、6、7轮排序结果都一样，即当数列已经排好序后，还在继续进行下一轮的比较，然后排序，很显然，这是多余的。当整个数列已经排好序后我们就没有必要再做多余的比较了，这时，可以用一个标记来表示上次内层循环是否有元素交换，如果有则进行下一轮循环，否则退出，因为所有元素已经有序。

优化如下：

	var array = [6, 5, 3, 1, 8, 7, 2, 4], // 未排序数组
		count = 0, // 记录排序总循环次数
		tmp, // 临时变量，用于交换元素位置
		flag; // 标记是否需要继续排序，true为继续排序 false为排序结束

	console.log("排序前：", array);

	for (var i = 0, len = array.length - 1; i < len; i++) { // 控制比较轮数
		flag = false; // 每轮先默认该轮排序后就不需要再排
		for (var j = 0, l = len - i; j < l; j++) { // 控制每轮比较次数
			count++; // 记录循环次数
			if (array[j] > array[j + 1]) {
				tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
				flag = true; // 有元素位置交换，下一轮还需要比较排序
			}
		}

		console.log("第" + (i + 1) + "轮排序：", array);
		if (!flag) // 下一轮不需要继续判断排序，退出循环
			break;
	}

	console.log("排序后：", array);
	console.log("共执行循环次数：", count);

执行结果：

	排序前： [6, 5, 3, 1, 8, 7, 2, 4]
	第1轮排序： [5, 3, 1, 6, 7, 2, 4, 8]
	第2轮排序： [3, 1, 5, 6, 2, 4, 7, 8]
	第3轮排序： [1, 3, 5, 2, 4, 6, 7, 8]
	第4轮排序： [1, 3, 2, 4, 5, 6, 7, 8]
	第5轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	第6轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	排序后： [1, 2, 3, 4, 5, 6, 7, 8]
	共执行循环次数： 27

这次测试结果比第一次测试结果少了一轮排序，比较次数少了1次，但我们发现，第5轮与第6轮仍然最终结果是一致的，即第5轮已经有序了，因此下次循环完全没有必要再继续对其比较。我们可以增加一个位置变量来记录每次冒泡的最后交换的位置，下次比较到此处就可以了，避免对后面已经有序的元素重复进行比较。

继续优化如下：

	var array = [6, 5, 3, 1, 8, 7, 2, 4], // 未排序数组
		count = 0, // 记录排序总循环次数
		tmp, // 临时变量，用于交换元素位置
		flag, // 标记是否需要继续排序，true为继续排序 false为排序结束
		index = array.length - 1; // 用于记录最后一次交换的位置

	console.log("排序前：", array);

	for (var i = 0, len = array.length - 1; i < len; i++) { // 控制比较轮数
		flag = false; // 每轮先默认该轮排序后就不需要再排
		for (var j = 0, l = index; j < l; j++) { // 控制每轮比较次数
			count++; // 记录循环次数
			if (array[j] > array[j + 1]) {
				tmp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = tmp;
				flag = true; // 有元素位置交换，下一轮还需要比较排序
				index = j; // 记录最后一次交换的位置
			}
		}

		console.log("第" + (i + 1) + "轮排序：", array);
		if (!flag) // 下一轮不需要继续判断排序，退出循环
			break;
	}

	console.log("排序后：", array);
	console.log("共执行循环次数：", count);

执行结果：

	排序前： [6, 5, 3, 1, 8, 7, 2, 4]
	第1轮排序： [5, 3, 1, 6, 7, 2, 4, 8]
	第2轮排序： [3, 1, 5, 6, 2, 4, 7, 8]
	第3轮排序： [1, 3, 5, 2, 4, 6, 7, 8]
	第4轮排序： [1, 3, 2, 4, 5, 6, 7, 8]
	第5轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	第6轮排序： [1, 2, 3, 4, 5, 6, 7, 8]
	排序后： [1, 2, 3, 4, 5, 6, 7, 8]
	共执行循环次数： 26

### 1.4 小结 ###

若数列的初始状态是正序的，一趟扫描即可完成排序。所需的比较次数 C 和记录移动次数 M 均达到最小值：C=n-1，M=0。这是冒泡排序最好的时间复杂度：O(n)。

若初始数列是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：C=n*(n-1)/2，M=3*n*(n-1)/2。因此，冒泡排序的最坏时间复杂度为 O(n^2)。